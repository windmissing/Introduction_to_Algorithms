# 一、题目

a)给定一个整数数组，其中不同的整数中包含的数字个数可能不同，但是该数组中，所有整数中总的数字数为n。说明如何在O(n)时间内对该数组进行排序

b)给定一个字符串数组，其中不同的串包含的字符个数可能不同，但所有串中总的字符个数为n。说明如何在O(n)时间内对该数组进行排序

（注意此处的顺序是指标准的字母顺序，例如，a < ab < b）

 

# 二、思路

这两题方法是一样的，仅仅是数据类型和进制的区别。  
本文就以a)为例。  

假设：  
n：所有整数中总的字数  
NUMBER_COUNT：数组中整数的个数  
MAX_DIGIT：数组中具有位数最多的那个数的位数  

本章主题是非比较排序，又因为题目中已有暗示，效率与数字的位数有关，因此很容易想到的是基数排序。  
原始基数排序的时间复杂度：O(NUMBER_COUNT * MAX_DIGIT)  

很显然，原始的基数排序不能满足需求，要作一些改进。  
分析发现，所有的整数都必须要经过MAX_DIGIT次计算，实际上，对于数位不足的MAX_DIGIT的整数，是不需要计算那么多次的。  
如果先对所有的整数分类，位数少的整数，就计算次数少一点，位数多的整数多计算多一点。  

这个预分类，就是桶排序的思想了。  
先根据整数的位数分装到不同的桶中，然后对每个桶分别做基数排序，这样，有些桶中的元素就不需要计算那么多次了。  
最极端的方法，就是每个位数一个桶了 。  
那么就是MAX_DIGIT个桶，每i个桶装的是具有i位数的整数。  
这个桶中的元素只需要做i次计算。  

原始的桶排序是有链表实现的。  
但是考虑到接下来要对每个桶做基数排序，链表做的桶就不合适了，因为基数排序需要对数据的随机访问。  
于是我只是借用了桶排序的预分类思想，而在实际代码中是以数组的方式实现了。  
即，仍是同样的大小的数组，但是按位数从小到大排。相同位数的数不排序。  

如果把每个元素的位数看成是这个元素的关键字，然后以关键字从小到大的排序的话，是不是有点像计数排序了？  
哇！小小一道题，竟然融合了桶排序、计数排序、基数排序这三种最主要的非比较排序，太厉害了！  
1.借用桶排序的思想，先根据位数对所有元素粗排序，然后对每个桶中的元素，根据元素本身的大小进行精确排序  
2.粗排序使用计数排序O(NUMBER_COUNT)  
3.精确排序使用基数排序O(MAX_DIGIT)  

也可以用字典树，见12-2-基数树

# 三、代码

[产品代码](https://code.csdn.net/mishifangxiangdefeng/algoritmcollection/tree/master/src/Exercise8_3.cpp)  
[测试代码](https://code.csdn.net/mishifangxiangdefeng/algoritmcollection/tree/master/src/Exercise8_3.cpp)