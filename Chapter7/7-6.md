# 一、题目

考虑这样一种排序问题,即无法准确的知道等排序的各个数字到底是多大.对于其中的每个数字,我们只知道它落在实轴上的某个区间内.亦即,给定的 n 个形如[ai, bi ]的闭区间,其中ai,≤bi .算法的目标是对这些区间进行模糊排序(fuzzy-sort),亦即,产生各区间的一个排序<i1, i2, i3, i4,…in >,使得存在一个 cj ∈[ai, bi ],满足c1≤c2≤…≤cn .  

a)       为n个区间的模糊排序设计一个算法,你的算法应该具有算法的一般结构,它可以快速排序左部端点(即各ai ),也要能充分利用重叠区间来改善运行时间.(随着各区间重叠得越来越多,对各区间的排序的问题会变得越来越容易,你的算法应该能充分利用这种重叠.)

b)      证明: 在一般情况下,你的算法的区望运行时间为 O(n*lgn),但当所有的区间都重叠时,期望的运行时间为O(n) (亦即,当存在一个值 x, 使得对所有的 i, 都有x∈[ai, bi ] ).你的算法不应显式的检查这种情况,而是应当随着重叠量的增加,性能自然地有所改善.


# 二、思考

借用快排的划分思路，以某个元素为主元，把区域划分成三段，第一段都小于主元，第二段都等于主元

重点是划分，区间如果重叠的部分，就把它们看做是相等的，并提取公共部分继续划分

a.end < b.start ==> a < b

a.start > b.end ==> a > b

其它情况 ==> a = b

为了避免类似于(2,2) (7,7) (1,8)这样的情况，相等时要提取公因子，并更新主元（主元不一等是某个元素）

具体解释都在代码中

# 三、代码

[产品代码](https://code.csdn.net/mishifangxiangdefeng/algoritmcollection/tree/master/src/Exercise7_6.cpp)  
[测试代码](https://code.csdn.net/mishifangxiangdefeng/algoritmcollection/tree/master/tst/cases/Exercise7_6Test.cpp)